

	=== УПРАВЛЕНИЕ ПОТОКОМ TCP ===
		
		- Это способ предотвращения отправки в сеть слишком большого количества сегментов, которые не могут быть приняты
		  получателем, у которого либо недостаточно места в буфере.

		TCP для повышения скорости работы в быстрых сетях использует скользящее окно. При этом отправитель передает
		в сеть большое количество сегментов, не дожидаясь подтверждения. Эти сегменты хорошо занимают пропускную
		способность широкого канала.
		
		!НО
		- Что произойдет, если получает данные не высокопроизводительный компьютер, а маленький телефон или какое-то
		  другое медленное устройство. В этом случае получатель примет несколько сегментов, а остальные будет вынужден
		  отбросить.
		* Задача предотвращения отправки быстрым отправителем слишком большого количества сегментов, которые не могут
		  быть получены медленным получателем (затопление), в TCP называются УПРАВЛЕНИЕ ПОТОКОМ.
		* Может быть и другая причина затопления, связанная с тем, что на транспортном уровне мы работаем с приложением,
		  в отличие от сетевого и канального уровня, где коммутаторы и маршрутизаторы должны обрабатывать данные сразу,
		  как только они пришли, приложение не обязано сразу обрабатывать данные. Приложение может читать данные из
		  буфера значительно медленнее, чем они туда поступают.
		  Данные, которые приходят из сети, записываются в некоторый промежуточный буфер. Откуда их со временем должно
		  прочитать приложение.
		  !!НО
		  - Что произойдет, если приложение данные не читает. А буфер почти занят. При этом отправитель передает гораздо
			больше сегментов, чем может поместиться в буфер - в результате часть сегментов будет отброшена.
		  - Чтобы дать понять отправителю, сколько данных получатель готов принять, используется поле - РАЗМЕР ОКНА
			в заголовке TCP. В этом поле получатель указывает, сколько байт данных он может принять.
		
		РАЗМЕР ОКНА:
		1. Предположим, размер буфера получателя равен 8 сегментам
		2. Отправитель передает сегмент (1000), он записывается в буфер, получатель передает подтверждение получения 
		   сегмента ACK 2460.
		   В подтверждении указывается номер следующего ожидаемого байта, а также размер окна (например, 10220. Что
		   соответствует 7 сегментам - 1460*7=10220
		3. Отправитель передает сразу 4 сегмента. Получатель отправляет подтверждение, где указывает новый размер окна
		   ACK 8300 (3*1460=4380 байт).
		4. Предположим, приложение не читает сегменты, занято другими делами. И отправитель передает 3 сегмента. Они
		   записываются в буфер, и в буфере место заканчивается. Получатель, передавая подтверждение, указывает, что 
		   размер окна равен 0. Этим он говорит, чтобы отправитель остановился и пока ничего не передавал.
		   Отправитель делает паузу и ждет следующего сообщения.
		5. Приложение прочитало часть данных из буфера, освободилось место для 2-х сегментов. Получатель заново
		   отправляет подтверждение последнего принятого байта 12680 и указывает размер окна 2920. 
		6. Отправитель снова передает эти 2 сегмента, которые снова записываются в буфер.
		*  Отравитель, если ждет слишком долго, может отправить Zero Window Probe - просьба подтвердить, что размер
		   окна все еще равен нулю. Нужно, чтобы убедиться, что не произошло каких-то ошибок.
